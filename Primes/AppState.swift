//
//  AppState.swift
//  Primes
//
//  Created by Daniel Wallace on 13/09/19.
//  Copyright Â© 2019 danwallacenz. All rights reserved.
//

import Foundation
import Combine

final class Store<Value, Action>: ObservableObject {
    
    let reducer: (inout Value, Action) -> Void
    
    @Published var value: Value

    init(initialValue: Value,
         reducer: @escaping (inout Value, Action) -> Void) {
        self.value = initialValue
        self.reducer = reducer
    }
    
    func send(_ action: Action) {
        reducer(&value, action)
    }
}

func pullback<LocalValue, GlobalValue, Action>(
    _ reducer: @escaping (inout LocalValue, Action) -> Void,
    value: WritableKeyPath<GlobalValue, LocalValue>
) -> (inout GlobalValue, Action) -> Void {
    
    return { globalValue, action in
        reducer(&globalValue[keyPath: value], action)
    }
}

/// Combine many reducers into one
func combine<Value, Action>(
    _ reducers: (inout Value, Action) -> Void...
    ) -> (inout Value, Action) -> Void {
    
    return { value, action in
        for reducer in reducers {
            reducer(&value, action)
        }
    }
}

// MARK:- Actions

enum CounterAction {
    case decrTapped
    case incrTapped
}

enum IsPrimeModalAction {
    case addFavouritePrimeTapped
    case removeFavouritePrimeTapped
}

enum FavouritePrimesAction {
    case deleteFavouritePrime(IndexSet)

    // generated by generate-enum-properties
    var deleteFavouritePrime: IndexSet? {
        get {
            guard case let .deleteFavouritePrime(value) = self else { return nil }
            return value
        }
        set {
            guard case .deleteFavouritePrime = self, let newValue = newValue else { return }
            self = .deleteFavouritePrime(newValue)
        }
    }
}

enum AppAction {
    case counter(CounterAction)
    case isPrimeModal(IsPrimeModalAction)
    case favouritePrimes(FavouritePrimesAction)

    // generated by generate-enum-properties
    var counter: CounterAction? {
        get {
            guard case let .counter(value) = self else { return nil }
            return value
        }
        set {
            guard case .counter = self, let newValue = newValue else { return }
            self = .counter(newValue)
        }
    }

    // generated by generate-enum-properties
    var isPrimeModal: IsPrimeModalAction? {
        get {
            guard case let .isPrimeModal(value) = self else { return nil }
            return value
        }
        set {
            guard case .isPrimeModal = self, let newValue = newValue else { return }
            self = .isPrimeModal(newValue)
        }
    }

    // generated by generate-enum-properties
    var favouritePrimes: FavouritePrimesAction? {
        get {
            guard case let .favouritePrimes(value) = self else { return nil }
            return value
        }
        set {
            guard case .favouritePrimes = self, let newValue = newValue else { return }
            self = .favouritePrimes(newValue)
        }
    }
}

// MARK:- Reducers

// Enums also have two very fundamental operations that can be performed on them, and they are pretty similar to the get and set of key paths. For some enum type, you can take a value and embed it into one of the cases of the enum, or you can take a value of the enum and try to extract out the associated data in one of its cases.
//struct _KeyPath<Root, Value> {
//  let get: (Root) -> Value
//  let set: (inout Root, Value) -> Void
//}
//AppAction.counter(CounterAction.decrTapped)

//AppAction.favouritePrimes(FavouritePrimesAction.deleteFavouritePrime([1]))
//let action = AppAction.favoritePrimes(.deleteFavoritePrimes([1]))
//let favoritePrimesAction: FavoritePrimesAction?
//switch action {
//case let .favoritePrimes(action):
//    favoritePrimesAction = action
//default:
//    favoritePrimesAction = nil
//}

//struct EnumKeyPath<Root, Value> {
//  let embed: (Value) -> Root
//  let extract: (Root) -> Value?
//}

// \AppAction.counter // EnumKeyPath<AppAction, CounterAction>

// pass only the part of the AppState we care about (count)
//func counterReducer(state: inout Int, action: CounterAction) -> Void {
func counterReducer(state: inout Int, action: AppAction) -> Void {
    
    switch action {
    case .counter(.decrTapped):
        state -= 1
    
    case .counter(.incrTapped):
        state += 1
    
    default:
        break
    }
}

func isPrimeModalReducer(state: inout AppState, action: AppAction) -> Void {
    
    switch action {
    case .isPrimeModal(.addFavouritePrimeTapped):
        state.favouritePrimes.append(state.count)
        state.activityFeed.append(Activity(timestamp: Date(), type: .addedFavoritePrime(state.count)))

    case .isPrimeModal(.removeFavouritePrimeTapped):
        let count = state.count // must do this when using inout
        state.favouritePrimes.removeAll(where: { $0 == count })
        state.activityFeed.append(Activity(timestamp: Date(), type: .removedFavoritePrime(state.count)))
        
    default:
        break
    }
}

extension AppState {
    var favouritePrimesState: FavouritePrimesState {
        get {
            FavouritePrimesState(
                favouritePrimes: self.favouritePrimes,
                activityFeed: self.activityFeed
            )
        }
        set {
            self.favouritePrimes = newValue.favouritePrimes
            self.activityFeed = newValue.activityFeed
        }
    }
}

struct FavouritePrimesState {
    var favouritePrimes: [Int]
    var activityFeed: [Activity]
}


// pass only the parts of the AppState we care about (favouritePrimes and activityFeed)
func favouritePrimesReducer(state: inout FavouritePrimesState, action: AppAction) -> Void {
    
    switch action {
    case .favouritePrimes(.deleteFavouritePrime(let indexSet)):
        for index in indexSet {
            let prime = state.favouritePrimes[index]
            state.favouritePrimes.removeAll(where: { $0 == prime })
            state.activityFeed.append(Activity(timestamp: Date(), type: .removedFavoritePrime(prime)))
        }
   
    default:
        break
    }
}

// MARK: - App Reducer

let appReducer = combine(
    pullback(counterReducer, value: \.count),
    isPrimeModalReducer,
    pullback(favouritePrimesReducer, value: \.favouritePrimesState)
)

// MARK: -

struct AppState {
    
    var count = 0 {
        didSet { saveState() }
    }
    
    var favouritePrimes: [Int] = [] {
        didSet { saveState() }
    }
    
    var activityFeed: [Activity] = [] {
        didSet {
            saveState()
        }
    }

    init() {}

    static func loadOrCreateAppState() -> AppState {
        if let jsonData = UserDefaults.standard.data(forKey: "APP_STATE"),
            let appState = try? JSONDecoder().decode(AppState.self, from: jsonData) {
            print(appState)
            return appState
        } else {
            return AppState()
        }
    }
}

// MARK:- Codable

extension AppState: Codable {
    
    enum CodingKeys: String, CodingKey {
        case count
        case favouritePrimes
        case activityFeed
    }
    
    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        count = try values.decode(Int.self, forKey: .count)
        favouritePrimes = try values.decode([Int].self, forKey: .favouritePrimes)
        activityFeed = try values.decode([Activity].self, forKey: .activityFeed)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(count, forKey: .count)
        try container.encode(favouritePrimes, forKey: .favouritePrimes)
        try container.encode(activityFeed, forKey: .activityFeed)
    }
    
    private func saveState() {
        if let json = try? JSONEncoder().encode(self) {
            UserDefaults.standard.set(json, forKey: "APP_STATE")
        } else {
            print("could not encode \(self)")
        }
    }
}

// MARK:-

extension AppState: CustomStringConvertible {
    var description: String {
        "count: \(count)\nfavourite primes:\(favouritePrimes)\nactivity: \(activityFeed)"
    }
}
