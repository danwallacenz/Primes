//
//  AppState.swift
//  Primes
//
//  Created by Daniel Wallace on 13/09/19.
//  Copyright Â© 2019 danwallacenz. All rights reserved.
//

import Foundation
import Combine

final class Store<Value, Action>: ObservableObject {
    
    let reducer: (inout Value, Action) -> Void
    
    @Published var value: Value

    init(initialValue: Value,
         reducer: @escaping (inout Value, Action) -> Void) {
        self.value = initialValue
        self.reducer = reducer
    }
    
    func send(_ action: Action) {
        reducer(&value, action)
    }
}

func pullback<LocalValue, GlobalValue, GlobalAction, LocalAction>(
    _ reducer: @escaping (inout LocalValue, LocalAction) -> Void,
    value: WritableKeyPath<GlobalValue, LocalValue>,
    action: WritableKeyPath<GlobalAction, LocalAction?>
) -> (inout GlobalValue, GlobalAction) -> Void {
    
    return { globalValue, globalAction in
        guard let localAction = globalAction[keyPath: action] else { return }
        reducer(&globalValue[keyPath: value], localAction)
    }
}

/// Combine many reducers into one
func combine<Value, Action>(
    _ reducers: (inout Value, Action) -> Void...
    ) -> (inout Value, Action) -> Void {
    
    return { value, action in
        for reducer in reducers {
            reducer(&value, action)
        }
    }
}

// MARK: -

struct AppState {
    
    var count = 0 {
        didSet { saveState() }
    }
    
    var favouritePrimes: [Int] = [] {
        didSet { saveState() }
    }
    
    var activityFeed: [Activity] = [] {
        didSet {
            saveState()
        }
    }
}

// MARK:- Actions

enum CounterAction {
    case decrTapped
    case incrTapped
}

enum IsPrimeModalAction {
    case addFavouritePrimeTapped
    case removeFavouritePrimeTapped
}

enum FavouritePrimesAction {
    case deleteFavouritePrime(IndexSet)

    // generated by generate-enum-properties
    // allows keypath acces to enum properties
    var deleteFavouritePrime: IndexSet? {
        get {
            guard case let .deleteFavouritePrime(value) = self else { return nil }
            return value
        }
        set {
            guard case .deleteFavouritePrime = self, let newValue = newValue else { return }
            self = .deleteFavouritePrime(newValue)
        }
    }
}

enum AppAction {
    case counter(CounterAction)
    case isPrimeModal(IsPrimeModalAction)
    case favouritePrimes(FavouritePrimesAction)

    // generated by generate-enum-properties
    // allows keypath acces to enum properties
    var counter: CounterAction? {
        get {
            guard case let .counter(value) = self else { return nil }
            return value
        }
        set {
            guard case .counter = self, let newValue = newValue else { return }
            self = .counter(newValue)
        }
    }

    // generated by generate-enum-properties
    // allows keypath acces to enum properties
    var isPrimeModal: IsPrimeModalAction? {
        get {
            guard case let .isPrimeModal(value) = self else { return nil }
            return value
        }
        set {
            guard case .isPrimeModal = self, let newValue = newValue else { return }
            self = .isPrimeModal(newValue)
        }
    }

    // generated by generate-enum-properties
    // allows keypath acces to enum properties
    var favouritePrimes: FavouritePrimesAction? {
        get {
            guard case let .favouritePrimes(value) = self else { return nil }
            return value
        }
        set {
            guard case .favouritePrimes = self, let newValue = newValue else { return }
            self = .favouritePrimes(newValue)
        }
    }
}

// MARK:- Reducers

/// Pass only the part of the AppState we care about (count) and the specific action - CounterAction
func counterReducer(state: inout Int, action: CounterAction) -> Void {
    
    switch action {
    case .decrTapped:
        state -= 1
    
    case .incrTapped:
        state += 1
    }
}

///  Pass only the specific action - IsPrimeModalAction. Uses most of the AppState so we'll just pass that all in
func isPrimeModalReducer(state: inout AppState, action: IsPrimeModalAction) -> Void {
    
    switch action {
    case .addFavouritePrimeTapped:
        state.favouritePrimes.append(state.count)
        state.activityFeed.append(Activity(timestamp: Date(), type: .addedFavoritePrime(state.count)))

    case .removeFavouritePrimeTapped:
        let count = state.count // must do this when using inout
        state.favouritePrimes.removeAll(where: { $0 == count })
        state.activityFeed.append(Activity(timestamp: Date(), type: .removedFavoritePrime(state.count)))
    }
}

/// used in favouritePrimesReducer. keypath \.favouritePrimesState
extension AppState {
    var favouritePrimesState: FavouritePrimesState {
        get {
            FavouritePrimesState(
                favouritePrimes: self.favouritePrimes,
                activityFeed: self.activityFeed
            )
        }
        set {
            self.favouritePrimes = newValue.favouritePrimes
            self.activityFeed = newValue.activityFeed
        }
    }
}

struct FavouritePrimesState {
    var favouritePrimes: [Int]
    var activityFeed: [Activity]
}


// pass only the parts of the AppState we care about (favouritePrimes and activityFeed)
func favouritePrimesReducer(state: inout FavouritePrimesState, action: FavouritePrimesAction) -> Void {
    
    switch action {
    case .deleteFavouritePrime(let indexSet):
        for index in indexSet {
            let prime = state.favouritePrimes[index]
            state.favouritePrimes.removeAll(where: { $0 == prime })
            state.activityFeed.append(Activity(timestamp: Date(), type: .removedFavoritePrime(prime)))
        }
    }
}

// MARK: - App Reducer

let _appReducer: (inout AppState, AppAction) -> Void = combine(
    pullback(counterReducer, value: \.count, action: \.counter),
    pullback(isPrimeModalReducer, value: \.self, action: \.isPrimeModal),
    pullback(favouritePrimesReducer, value: \.favouritePrimesState, action: \.favouritePrimes)
)
let appReducer = pullback(_appReducer, value: \.self, action: \.self)

// MARK:- AppState Codable

extension AppState: Codable {
    
    static func loadOrCreateAppState() -> AppState {
        if let jsonData = UserDefaults.standard.data(forKey: "APP_STATE"),
            let appState = try? JSONDecoder().decode(AppState.self, from: jsonData) {
            print(appState)
            return appState
        } else {
            return AppState()
        }
    }
    
    private func saveState() {
        if let json = try? JSONEncoder().encode(self) {
            UserDefaults.standard.set(json, forKey: "APP_STATE")
        } else {
            fatalError("could not encode \(self)")
        }
    }
    
    enum CodingKeys: String, CodingKey {
        case count
        case favouritePrimes
        case activityFeed
    }
    
    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        count = try values.decode(Int.self, forKey: .count)
        favouritePrimes = try values.decode([Int].self, forKey: .favouritePrimes)
        activityFeed = try values.decode([Activity].self, forKey: .activityFeed)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(count, forKey: .count)
        try container.encode(favouritePrimes, forKey: .favouritePrimes)
        try container.encode(activityFeed, forKey: .activityFeed)
    }
}

// MARK:-

extension AppState: CustomStringConvertible {
    var description: String {
        "count: \(count)\nfavourite primes:\(favouritePrimes)\nactivity: \(activityFeed)"
    }
}
